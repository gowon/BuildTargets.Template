namespace build.Commands;

using System.CommandLine;
using System.CommandLine.Invocation;
using Bullseye;
using static Bullseye.Targets;
using static SimpleExec.Command;

public class TargetsCommand : Command
{
    private const string ArtifactsDirectory = ".artifacts";
    private const string AutogeneratedDir = "Generated_Code";

    private static readonly Option<string> ConfigurationOption =
        new(new[] { "--configuration", "-C" }, () => "Release", "The configuration to run the target");

    public TargetsCommand() : base("targets", "Execute build targets")
    {
        AddOption(ConfigurationOption);
        ImportBullseyeConfigurations();

        this.SetHandler(async context =>
        {
            var configuration = context.ParseResult.GetValueForOption(ConfigurationOption);

            Target(Targets.CleanArtifactsOutput, () =>
            {
                if (Directory.Exists(ArtifactsDirectory))
                {
                    Directory.Delete(ArtifactsDirectory, true);
                }

                if (Directory.Exists(AutogeneratedDir))
                {
                    Directory.Delete(AutogeneratedDir, true);
                }
            });

            Target(Targets.Pack, DependsOn(Targets.CleanArtifactsOutput),
                async () =>
                {
                    await RunAsync("dotnet",
                        $"pack Pack.csproj -o {Directory.CreateDirectory(ArtifactsDirectory).FullName} --nologo");
                });

            Target(Targets.RunTests, DependsOn(Targets.Pack), async () =>
            {
                // Uninstall BuildTool.Template
                await RunAsync("dotnet", "new uninstall BuildTool.Templates", handleExitCode: _ => true);

                // Install BuildTool.Template
                await RunAsync("dotnet",
                    $"new install {Path.Combine(ArtifactsDirectory, "BuildTool.Templates*.nupkg")}");

                // Apply template to folder
                await RunAsync("dotnet", $"new build-tool -o {AutogeneratedDir}");

                // Dry run
                await RunAsync("dotnet", $"run --project {Path.Combine(AutogeneratedDir, "build")} -- -?");
            });

            Target("default", DependsOn(Targets.RunTests));

            await RunBullseyeTargetsAsync(context);
        });
    }

    private void ImportBullseyeConfigurations()
    {
        Add(new Argument<string[]>("targets")
        {
            Description =
                "A list of targets to run or list. If not specified, the \"default\" target will be run, or all targets will be listed. Target names may be abbreviated. For example, \"b\" for \"build\"."
        });

        foreach (var (aliases, description) in Bullseye.Options.Definitions)
            Add(new Option<bool>(aliases.ToArray(), description));
    }

    private async Task RunBullseyeTargetsAsync(InvocationContext context)
    {
        var targets = context.ParseResult.CommandResult.Tokens.Select(token => token.Value);
        var options = new Options(Bullseye.Options.Definitions.Select(definition => (definition.Aliases[0],
            context.ParseResult.GetValueForOption(Options.OfType<Option<bool>>()
                .Single(option => option.HasAlias(definition.Aliases[0]))))));
        await RunTargetsWithoutExitingAsync(targets, options);
    }
}

internal static class Targets
{
    public const string CleanArtifactsOutput = "clean-artifacts-output";
    public const string Pack = "pack";
    public const string RunTests = "run-tests";
}